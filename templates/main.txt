package gen

import (
	"context"
	"errors"
	"reflect"

	"{{.StructImport}}"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

type {{.Name}}Model struct {
	dbColl *mongo.Collection
}

type {{.Name}}Document struct {
	dbColl *mongo.Collection
	raw    *{{.StructType}}
}

func (userDocument *{{.Name}}Document) Save(ctx context.Context) error {
	// TODO: implement difftracker
	if userDocument.raw.ID == nil {
		return errors.New("_id is nil")
	}
	structValueRef := reflect.ValueOf(userDocument.raw).Elem()
	structTypeRef := reflect.TypeOf(userDocument.raw).Elem()

	nFields := structTypeRef.NumField()
	fieldToUpdate := bson.M{}
	for i := 0; i < nFields; i++ {
		field := structTypeRef.Field(i)
		fieldName := gogoose.GetBsonName(field)
		if fieldName == "_id" {
			continue
		}
		// fmt.Println(structValueRef.Field(i))
		fieldToUpdate[fieldName] = structValueRef.Field(i).Interface()
	}
	_, err := userDocument.dbColl.UpdateOne(ctx, bson.M{"_id": userDocument.raw.ID}, bson.M{"$set": fieldToUpdate}, options.Update().SetUpsert(true))
	return err
}

func (userModel *{{.Name}}Model) Find(ctx context.Context, filter interface{}, opts ...*options.FindOptions) ([]*{{.Name}}Document, error) {
	cursor, err := userModel.dbColl.Find(ctx, filter, opts...)
	if err != nil {
		return nil, err
	}
	docs := make([]*{{.Name}}Document, 0, 0)
	for cursor.Next(ctx) {
		user := &{{.StructType}}{}
		err := bson.Unmarshal(cursor.Current, user)
		if err != nil {
			return docs, err
		}
	}
	return docs, cursor.Err()
}

func (userModel *{{.Name}}Model) FindOne(ctx context.Context, filter interface{}, opts ...*options.FindOneOptions) (*{{.Name}}Document, error) {
	res := userModel.dbColl.FindOne(ctx, filter)
	user := &{{.StructType}}{}
	err := gogoose.DecodeSingleResult(res, user)
	if err != nil {
		return nil, err
	}
	return New{{.Name}}Document(user, userModel.dbColl), nil
}

func (userModel *{{.Name}}Model) FindOneAndUpdate(ctx context.Context, filter interface{}, update interface{}, opts ...*options.FindOneAndUpdateOptions) (*{{.Name}}Document, error) {
	res := userModel.dbColl.FindOneAndUpdate(ctx, filter, update, opts...)
	user := &gogoose.User{}
	err := gogoose.DecodeSingleResult(res, user)
	if err != nil {
		return nil, err
	}
	return NewUserDocument(user, userModel.dbColl), nil
}

func (userModel *{{.Name}}Model) FindOneAndDelete(ctx context.Context, filter interface{}, opts ...*options.FindOneAndDeleteOptions) (*{{.Name}}Document, error) {
	res := userModel.dbColl.FindOneAndDelete(ctx, filter, opts...)
	user := &gogoose.User{}
	err := gogoose.DecodeSingleResult(res, user)
	if err != nil {
		return nil, err
	}
	return NewUserDocument(user, userModel.dbColl), nil
}

func (userModel *{{.Name}}Model) FindOneAndReplace(ctx context.Context, filter interface{}, update interface{}, opts ...*options.FindOneAndReplaceOptions) (*{{.Name}}Document, error) {
	res := userModel.dbColl.FindOneAndReplace(ctx, filter, update, opts...)
	user := &gogoose.User{}
	err := gogoose.DecodeSingleResult(res, user)
	if err != nil {
		return nil, err
	}
	return NewUserDocument(user, userModel.dbColl), nil
}

func (userModel *{{.Name}}Model) UpdateOne(ctx context.Context, filter interface{}, update interface{}, opts ...*options.UpdateOptions) (*mongo.UpdateResult, error) {
	return userModel.dbColl.UpdateOne(ctx, filter, update, opts...)
}

func (userModel *{{.Name}}Model) UpdateMany(ctx context.Context, filter interface{}, update interface{}, opts ...*options.UpdateOptions) (*mongo.UpdateResult, error) {
	return userModel.dbColl.UpdateMany(ctx, filter, update, opts...)
}

func (userModel *{{.Name}}Model) DeleteOne(ctx context.Context, filter interface{}, opts ...*options.DeleteOptions) (*mongo.DeleteResult, error) {
	return userModel.dbColl.DeleteOne(ctx, filter, opts...)
}

func (userModel *{{.Name}}Model) DeleteMany(ctx context.Context, filter interface{}, opts ...*options.DeleteOptions) (*mongo.DeleteResult, error) {
	return userModel.dbColl.DeleteMany(ctx, filter, opts...)
}
 
func (userModel *{{.Name}}Model) New(user *{{.StructType}}) *{{.Name}}Document {
	return &{{.Name}}Document{raw: user, dbColl: userModel.dbColl}
}

// New{{.Name}}Document ...
func New{{.Name}}Document(user *{{.StructType}}, coll *mongo.Collection) *{{.Name}}Document {
	return &{{.Name}}Document{
		dbColl: coll,
		raw:    user,
	}
}

func New{{.Name}}Model(collection *mongo.Collection) *{{.Name}}Model {
	return &{{.Name}}Model{dbColl: collection}
}
